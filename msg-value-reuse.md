## ```msg.value``` reused in a loop

* Vulnerability ID: ```solidity-msg-value-reuse-loop```
* Severity: High
* Confidence: Medium
* Difficulty: Easy
* Versions affected: All

## Detection rule: 
Flag if ```msg.value``` is referenced inside a loop body.

## Historic Exploit: 
https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong

## Vulnerable Example
```solidity
// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

contract Mint {
    
    mapping (uint => address) nftOwners;

    function buyMultipleNFTs(address[] memory addrs) external payable{
        
        for (uint i = 0; i < addr.length; i++) {
            buyOneNFT(addr[i])
        }
        
        function buyOneNFT(address to) internal {
            if (msg.value < 1 ether) { revert("not enough ether") }
            nftOwners[numero] = address;
        }
    }
}
```

### Why is this a problem?
```msg.value``` is constant in any transaction. If business logic dependent state changes between iterations of the loop, ```msg.value``` will be an inaccurate reflection of state in later loop iterations. Using ```msg.value``` in a loop is also trivially non-optimal for gas usage compared to tracking the value in a local variable in the loop body.

#### Further reading:
https://trustchain.medium.com/ethereum-msg-value-reuse-vulnerability-5afd0aa2bcef

###

## Corrected Example 
#### Instead, track ```msg.value``` through a local variable, decrease its value on each iteration
```solidity
// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

contract Mint {
    mapping(uint => address) nftOwners;

    function buyMultipleNFTs(address[] memory addrs) external payable {
        // Track the total payment using a local variable
        uint256 totalPayment = msg.value; 
        
        for (uint i = 0; i < addrs.length; i++) {
            buyOneNFT(addrs[i], totalPayment);
            totalPayment -= 1 ether; // Deduct the payment for each NFT
        }
    }
    
    function buyOneNFT(address to, uint256 totalPayment) internal {
        // Check the totalPayment against the desired value
        require(totalPayment >= 1 ether, "Not enough ether"); 
        nftOwners[numero] = to;
    }
}
```
