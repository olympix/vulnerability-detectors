## Directional override character in source

* **Vulnerability ID:** `directional-override-character`
* **Severity:** `High`
* **Confidence:** `High`
* **Difficulty:** Easy
* **Versions affected:** All

## Detection rule
Flag if a contract contains a left-to-right override character (U+202D) or right-to-left override character (U+202E) in the source code.

## Historic Exploit:

## Vulnerable Example
```solidity
// SPDX-License-Identifier: Unlicense
pragma solidity 0.8.0;

contract Token
{
    address payable o; // owner
    mapping(address => uint) tokens;

    function withdraw() external returns(uint)
    {
        uint amount = tokens[msg.sender];
        address payable d = msg.sender;
        tokens[msg.sender] = 0;
        _withdraw(/*owner‮/*noitanitsed*/ d, o/*‭
		        /*value */, amount);
    }

    function _withdraw(address payable fee_receiver, address payable destination, uint value) internal
    {
		fee_receiver.transfer(1);
		destination.transfer(value);
    }
}
```

### Why is this a problem?
In the code above, an attacker could abuse the withdraw function to receive transfers they were not entitled to.

#### Further reading:

## Corrected Example
#### Avoid using special control characters in source code.
```solidity
// SPDX-License-Identifier: Unlicense
pragma solidity 0.8.0;

contract Token
{
    address payable o; // owner
    mapping(address => uint) tokens;

    function withdraw() external returns(uint)
    {
        uint amount = tokens[msg.sender];
        address payable d = msg.sender;
        tokens[msg.sender] = 0;
        _withdraw(d, o, amount);
    }

    function _withdraw(address payable fee_receiver, address payable destination, uint value) internal
    {
		fee_receiver.transfer(1);
		destination.transfer(value);
    }
}
```
